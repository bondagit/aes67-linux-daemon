# Ravenna RTP stream redundancy

## Introduction

Redundancy in a Ravenna RTP stream is a feature that is facilitated by transmitting
the same audio data over two separate network paths. This is useful in situations
where users want to ensure that the audio data is transmitted even if one of the
network paths fails.

As the kernel module and the userspace daemon are currently only capable of handling
a single network device, redundancy must be handled on a different level. One
approach to achieve this is to leverage the `nftables` kernel network framework.

**Note** for the below approach to work, make sure that the kernel driver you are
using has [this commit](https://github.com/bondagit/ravenna-alsa-lkm/commit/e54346da729eeb80a0f88e2539e92ea0657a4bf4).

## Playback (egress)

### Create a dummy network interface

The first step is to create a dummy network interface. This is a virtual network
interface that discards all packets sent to it. This is sufficient for our purposes,
as we will capture and treat the packets before they end up at the interface.

```bash
ip link add name ravenna-dummy type dummy
ip link set ravenna-dummy up
```

Now set the `interface_name` property in the daemon to `ravenna-dummy`.

### nftables configuration

For egress packets (playback), the kernel module creates the RTP stream packets
and sends them directly to the queue of the configured network device.

As we are using a dummy network interface, the packets will eventually be discarded,
but we can use an `nftables` `egress` hook in a `netdev` chain to get a hold of them
before that happens.

The rule will duplicate and send the packets to the real network interfaces.

The problem however is that the packets will then have wrong source MAC and IP addresses,
which will likely cause other parts of the network topology to drop them.
So we need to rewrite these details in the `nftables` rules.

Suppose the network interfaces that we want to use for redundancy are `eth0` and `eth1`,
and the dummy network interface is `ravenna-dummy`. We can use the following `nftables`
configuration to duplicate the RTP stream packets and send them over both `eth0` and `eth1`:

```
define eth0_ip = 1.1.1.1
define eth1_ip = 2.2.2.2

define eth0_mac = 01:02:03:04:05:06
define eth1_mac = 11:12:13:14:15:16

define mcast_group_eth0 = 239.0.0.1
define mcast_group_eth1 = 239.0.0.2

table netdev redundancy-playback {
  chain egress {
    type filter hook egress device ravenna-dummy priority 0;
    ether saddr set $eth0_mac ip saddr set $eth0_ip ip daddr set $mcast_group_eth1 dup to eth0 notrack
    ether saddr set $eth1_mac ip saddr set $eth1_ip ip daddr set $mcast_group_eth2 dup to eth1 notrack
  }
}
```

### mDNS and SDP

The SDP generated by the AES67 daemon will contain only one media section, so
the stream won't be seen as redundant by the receiver.

You will hence have to manually create a new SDP file that contains two media
sections, one for each network interface, and ignore the one that is generated
by the daemon.

The mDNS announcements will end up on the dummy interface and hence go nowhere,
so it's best to disable mDNS in the daemon for this setup and use a different
method to announce the stream and serve the SDP through an RTSP server on the
real network interfaces.

How exactly this is done depends on the implementation of the sender side and
is not covered in this document.
